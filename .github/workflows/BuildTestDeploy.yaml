name: Build and Test CQRS Application

on:
  push:
    branches:
    - main
    - develop
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:

jobs:
  # build-and-test:
  #   environment: "AWS and Supabase"
  #   name: Build and Test CQRS Application
  #   runs-on: ubuntu-latest
  #   env:
  #     DB_URL: ${{ secrets.DB_URL }}
  #     DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
  #     DB_USER: ${{ vars.DB_USER }}
  #     DOCKERHUB_USER: ${{ vars.DOCKERHUB_USER }}
  #     DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
  #   steps:
  #     - name: Checkout repository with submodules
  #       uses: actions/checkout@v4
  #       with:
  #         submodules: 'recursive'

  #     - name: Set up JDK 21
  #       uses: actions/setup-java@v4
  #       with:
  #         java-version: '21'
  #         distribution: 'temurin'
  #         cache: 'maven'

  #     - name: build Command Unit
  #       run: |
  #         chmod +x mvnw
  #         ./mvnw flyway:migrate
  #         ./mvnw clean package -DskipTests
  #       working-directory: springboot_cqrs_command

  #     - name: Build Query Unit 
  #       run: |
  #           chmod +x mvnw
  #           ./mvnw clean package -DskipTests
  #       working-directory: springboot_cqrs_query

  #     - name: Start All Services
  #       run: |
  #         docker compose build --no-cache
  #         docker compose up -d

  #     - name: Verify services are running
  #       run: docker ps

  #     - name: Log in to Docker Hub
  #       uses: docker/login-action@v3
  #       with:
  #         username: ${{ vars.DOCKERHUB_USER }}
  #         password: ${{ secrets.DOCKERHUB_TOKEN }}
  #     - name: Build and push Docker image
  #       run: |
  #         docker compose -f compose.yaml push

  setup-terraform:
    environment: "AWS and Supabase"
    name: Set up AWS EC2 Instance with Terraform
    # needs: build-and-test
    runs-on: ubuntu-latest
    outputs:
      ec2_public_ip: ${{ steps.capture-ec2-ip.outputs.ec2_public_ip }}
    steps:
      - name: Checkout repository with submodules
        uses: actions/checkout@v4

      - name: Set up SSH key
        run: |
            mkdir -p ~/.ssh
            echo "${{ secrets.AWS_SSH_PUBLIC_KEY }}" > ~/.ssh/my_ec2_key.pub
            chmod 600 ~/.ssh/my_ec2_key.pub
            echo "SSH key set up successfully"

      - name: Setup AWS Credential     #TODO: Setup IAM User with Permission and generate credentials with Terraform
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION }}
      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.12.2
      - name: Terraform Init, Verify, and Plan
        run: |
          terraform init
          terraform validate
          terraform plan
        working-directory: envs/dev
      - name: Terraform Apply
        run: terraform apply -auto-approve
        working-directory: envs/dev
      - id: capture-ec2-ip
        name: Capture EC2 public IP output
        run: echo "ec2_public_ip=$(terraform output -raw ec2_public_ip)" >> $GITHUB_OUTPUT
        working-directory: envs/dev
  deploy-code:
    environment: "AWS and Supabase"
    name: Deploy Code to EC2 Instance
    runs-on: ubuntu-latest
    needs: 
      # - build-and-test
      - setup-terraform
    env:
      AWS_SSH_PRIVATE_KEY: ${{ secrets.AWS_SSH_PRIVATE_KEY }}
      EC2_PUBLIC_IP: ${{ needs.terraform.outputs.ec2_public_ip }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: SSH into EC2 instance
        run: |
          ssh -o StrictHostKeyChecking=no -i ${{ secrets.AWS_SSH_PRIVATE_KEY }} ec2-user@"$EC2_PUBLIC_IP" << 'EOF'
          docker compose -f compose.yaml up -d --no-build
          docker ps
          EOF